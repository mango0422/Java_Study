스레드를 생성하고 시작하면 스레드는 다양한 상태를 가지게 된다.
스레드의 상태는 자동으로 변경될 수도 있고, 코드에 의해서 변경될 수도 있다.
이번 절에서는 스레드의 상태를 변경해서 스레드를 제어하는 방법에 대해 알아보자.

 스레드 객체를 생성하고 start() 메소드를 호출하면 바로 실행되는 것이 아니라 실행 대기 상태가 된다.
실행 대기 상태란 언제든지 실행할 준비가 되어 있는 상태를 말한다.
운영체제는 실행 대기 상태에 있는 스레드 중에서 하나를 선택해서 실행 상태로 만든다.
 실행 상태의 스레드는 run() 메소드를 모두 실행하기 전에 다시 실행 대기 상태로 돌아갈 수 있으며, 실행 대기 상태에 있는 다른 스레드가 선택되어 실행 상태가 되기도 한다.
실행 상태에서 run() 메소드의 내용이 모두 실행되면 스레드의 실행이 멈추고 종료 상태가 된다.
______________________________________________________________________________________________________________________________________________________________________________________

<스레드 상태>
스레드 객체를 생성하고 start() 메소드를 호출하면 곧바로 스레드가 실행되는 것처럼 보이지만 사실은 실행 대기 상태가 된다.
실행 대기 상태란 실행을 기다리고 있는 상태를 말한다.
실행 대기 상태에 있는 스레드 중에서 운영체제는 하나의 스레드를 선택하고 CPU(코어)가 run() 메소드를 실행하도록 한다.
이때를 실행(running)상태라고 한다.
실행 상태의 스레드는 run() 메소드를 모두 실행하기 전에 다시 실행 대기 상태로 돌아갈 수 있다.
그리고 실행 대기 상태에 있는 다른 스레드가 선택되어 실행 상태가 된다.
 이렇게 스레드는 실행 대기 상태와 실행 상태를 번갈아가면서 자신의 run() 메소드를 조금씩 실행한다.
실행 상태에서 run() 메소드가 종료되면, 더 이상 실행할 코드가 없기 때문에 스레드의 실행은 멈추게 된다.
이 상태를 종료(terminated)상태라고 한다.
 이처럼 스레드는 실행 대기 상태와 실행 상태로 번갈아 변하면서, 경우에 따라서 실행 상테에서 일시정지 상태로 가기도 한다.
일시 정지 상태는 스레드가 실행할 수 없는 상태이다.
일시 정지 상태에서는 바로 실행 상태로 돌아갈 수 없고, 일시 정지 상태에서 빠져나와 실행 대기 상태로 가야 한다.
______________________________________________________________________________________________________________________________________________________________________________________

<스레드 상태 제어>
사용자는 미디어 플레이어에서 동영상을 보다가 일시 정지할 수도 있고, 종료할 수도 있다.
일시 정지는 조금 후 다시 동영상을 보겠다는 의미이므로 미디어 플레이어는 동영상 스레드를 일시 정지 상태로 만들어야 한다.
그리고 종료는 더 이상 동영상을 보지 않겠다는 의미이므로 미디어 플레이어는 스레드를 종료 상태로 만들어야 한다.
이와 같이 실행 중인 스레드의 상태를 변경하는 것을 스레드 상태 제어라고 한다.
 멀티 스레드 프로그램을 만들기 위해서는 정교한 스레드 상태 제어가 필요한데, 상태 제어가 잘못되면 프로그램은 불안정해져서 먹통이 되거나 다운된다.
 스레드 제어를 제대로 하기 위해서는 스레드의 상태 변화를 가져오는 메소드를 파악하고 있어야 한다.
  *) 스레드 상태 제어는 주어진 시간동안 일시 정지시키는 sleep() 메소드와 스레드를 안전하게 종료시키는 stop 플래그, interrupt() 메소드를 사용한다.

메소드                  설명
interrupt()             일시 정지 상태의 스레드에서 interruptedException을 발생시켜, 예외 처리 코드(catch)에서 실행 대기 상태로 가거나 종료 상태로 갈 수 있도록 한다.
sleep(long millis)      주어진 시간 동안 스레드를 일시 정지 상태로 만든다. 주어진 시간이 지나면 자동적으로 실행 대기 상태가 된다.
stop()                  스레드를 즉시 종료한다. 불완전한 종료를 유발하므로 사용하지 않는 것이 좋다.

 * 주어진 시간 동안 일시 정지
 실행 중인 스레드를 일정 시간 멈추게 하고 싶다면 Thread 클래스의 정적 메소드인 sleep()을 사용하면 된다.
 다음과 같이 Thread.sleep() 메소드를 호출한 스레드는 주어진 시간 동안 일시 정지 상태가 되고, 다시 실행 대기 상태로 돌아간다.
 
 try{
    Thread.sleep(1000);
 } catch(interruptedException e){
    //interrupt() 메소드가 호출되면 실행
 }

 매개값에는 얼마 동안 일시 정지 상태로 있을 것인지 밀리세컨드(1/1000초) 단위로 시간을 주면 된다.
 위와 같이 1000이라는 값을 주면 스레드는 1초가 경과할 동안 일시 정지 상태로 있게 된다.
 일시 정지 상태에서 주어진 시간이 되기 전에 interrupt() 메소드가 호출되면 interruptedException이 발생하기 때문에 예외 처리가 필요하다.

 다음 에제는 3초 주기로 비프(beep)음을 10번 발생시킨다.
 ( SleepExample.java / package ch12.sec02.exam01; )

 10~12라인은 메인 스레드를 3초 동안 일시 정지 상태로 보내고, 3초가 지나면 다시 실행 준비 상태로 돌아오도록 했다.

 * 스레드의 안전한 종료
 스레드는 자신의 run() 메소드가 모두 실행되면 자동적으로 종료된다.
 하지만 경우에 따라서는 실행중인 스레드를 즉시 종료해야 할 때가 있다.
 예를 들어 동영상을 끝까지 보지 않고, 사용자가 멈춤을 요구할 수 있다.
  Thread는 스레드를 즉시 종료하기 위해 stop() 메소드를 제공하고 있는데, 이 메소드는 deprecated(중요도가 떨어져 이제 사용되지 않음)되었다.
 그 이유는 stop() 메소드로 스레드를 갑자기 종료하게 되면 스레드가 사용 중이던 자원들이 불안전한 상태로 남겨지기 때문이다.
 그렇다면 스레드를 즉시 종료하기 위한 최선의 방법은 무엇일까?
 (여기서 자원이란 파일, 네트워크 연결 등을 말한다.)
 지금부터 스레드를 안전하게 종료하는 방법에 대해 알아보자.

 * stop 플래그를 이용하는 방법
 스레드는 run() 메소드가 끝나면 자동적으로 종료되므로, run() 메소드가 정상적으로 종료되도록 유도하는 것이 중요하다.
 다음 코드는 stop 플르개를 이용해서 run() 메소드의 종료를 유도한다.
 
 public class XXXThread extends Thread{
   private boolean stop;   //stop 플래그 필드

   public void run(){
      while( !stop ){ // stop이 true가 되면 run() 종료
         스레드가 반복 실행하는 코드;
      }
      //스레드가 사용한 자원 정리
   }
 }

 위 코드에서 stop필드가 false일 경우에는 while문의 조건식이 true가 되어 반복 실행하지만, stop 필드가 true일 경우에는 while문의 조건식이 false가 되어 while문을 빠져나온다.
 그리고 스레드가 사용한 자원을 정리하고, run() 메소드가 끝나게 됨으로써 스레드는 안전하게 종료된다.
 
 다음 에제는 PrintThread1을 실행한 후 1초 후에 PrintThread1을 멈추도록 setStop() 메소드를 호출한다.
 ( StopFlagExample.java / package ch12.sec02.exam02; )

 * interrupt() 메소드를 이용하는 방법
 interrupt() 메소드는 스레드가 일시 정지 상태에 있을 때 InterruptException을 발생시키는 역할을 한다.
 이를 이용하면 run() 메소드를 정상 종료할 수 있다.
 예를 들어, ThreadA가 ThreadB를 생성해서 start() 메소드로 ThreadB를 실행했다고 가정해보자.
 ThreadA가 ThreadB의 interrup() 메소드를 실행하게 되면 ThreadB가 sleep() 메소드로 일시 정지 상태가 될 때 ThreadB에서 InterruptException이 발생하여 예외 처리(catch) 블록으로 이동한다.
 결국 ThreadB는 while문을 빠져나와 run() 메소드를 정상 종료하게 된다.

 다음 예제는 PrintThread2를 실행한 후 1초 후에 PrintThread2를 멈추도록 interrupt() 메소드를 호출한다
 ( InterruptExample.java / package ch12.sec02.exam03; )
 주목할 점은 스레드가 실행 대기 또는 실행 상태에 있을 때 interrupt() 메소드가 실행되면 즉시 InterruptedException이 발생하지 않고, 스레드가 미래에 일시 정지 상태가 되면 InterruptedException이 발생한다는 것이다.
 따라서 스레드가 일시 정지 상태가 되지 않으면 interrupt() 메소드 호출은 아무런 의미가 없다.
 그래서 짧은 시간이나마 일시 정지시키기 위해 8라인에서 Thread.sleep(1)을 사용한 것이다.

 일시 정지를 만들지 않고도 interrupt()의 호출 여부를 알 수 있는 방법이 있다.
 interrupt() 메소드가 호출되었다면 스레드의 interrupted()와 isInterrupted() 메소드는 ture를 리턴한다.
 interrupted()는 정적 메소드로 현재 스레드가 interrupted 되었는지 확인하는 것이고, isInterrupted()는 인스턴스 메소드로 현재 스레드가 interrupted되었는지 확인한다.
 둘 중 어떤 것을 사용해도 무방하다.

 boolean status = Thread.interrupted();
 boolean status = objThread.isInterrupted();

 다음은 일시 정지 코드인 Thread.sleep(1)을 사용하지 않고, Thread.interrupted()를 사용해서 PrintThread의 interrupt()가 호출되었는지 확인한 다음 while문을 빠져나가도록 했다.
 ( PrintThread2.java / package ch12.sec02.exam04; )
 ______________________________________________________________________________________________________________________________________________________________________________________

 ** 데몬 스레드
 데몬(daemon) 스레드는 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드이다.
 주 스레드가 종료되면 데몬 스레드는 강제적으로 자동 종료되는데, 그 이유는 주 스레드의 보조 역할을 수행하므로 주 스레드가 종료되면 데몬 스레드의 존재 의미가 사라지기 때문이다.
 이 점을 제외하면 데몬 스레드는 일반 스레드와 큰 차이가 없다.
  데몬 스레드의 적용 예는 워드프로세서의 자동 저장, 미디어 플레이어의 동영상 및 음악 재생, 쓰레기 수집기 등이 있는데, 이 기능들은 주 스레드(워드프로세서, 미디어플레이어, JVM)가 종료되면 같이 종료된다.
 스레드를 데몬으로 만들기 위해서는 주 스레드가 데몬이 될 스레드의 setDaemon(true)를 호출해주면 된다.
 아래 코드를 보면 메인 스레드가 주 스레드가 되고, AutoSaveThread가 데몬 스레드가 된다.

 public static void main(String[] args){
   AutoSaveThread thread = new AutoSaveThread();
   thread.setDaemon(true);
   thread.start();
   ...
 }

 주의할 점은 start() 메소드가 호출되고 나서 setDaemon(true)를 호출하면 IllegalThreadStateException이 발생하기 대문에 start() 메소드 호출 전에 setDaemon(true)를 호출해야 한다는 것이다.
  * 현재 실행 중인 스레드가 데몬 스레드인지 아닌지를 구별하려면 isDaemon() 메소드의 리턴값을 조사해보면 된다.
    데몬 스레드일 경우 true를 리턴한다.
 다음 예제는 1초 주기로 save() 메소드를 자동 호출하도록 AutoSaveThread를 작성하고, 메인 스레드가 3초 후 종료되면 AutoSaveThread도 같이 종료되도록 AutoSaveThread를 데몬 스레드로 만들었다.
 ( AutoSaveThread.java, DaemonExample.java / package ch12.sec02.exam05; )
 ______________________________________________________________________________________________________________________________________________________________________________________

 <확인문제>
 1. 스레드 상태 제어를 하는 메소드에 대한 설명 중 틀린 것은 무엇인가?
  1-1.start() 메소드는 실행 대기 상태로 만들어준다. (o)
  1-2.sleep() 메소드는 일시 정지 상태로 만들어준다. (o)
  1-3.interrupt() 메소드는 실행 상태를 간섭해서 일시 정지 상태로 만들어준다. (x)
  1-4.일시 정지 상태에서 실행 상태로 변경하는 메소드는 없다. (o)
 
 2. interrupt() 메소드를 호출한 효과에 대한 설명 중 틀린 것은 무엇인가?
  2-1.일시 정지 상태에서 InterruptedException을 발생시킨다. (o)
  2-2.스레드는 즉시 종료한다. (x)
  2-3.실행 대기 상태에서 호출되면 일시 정지 상태가 될 때까지 InterruptedException이 발생하지 않는다. (o)
  2-4.아직 InterruptedException이 발생하지 않았다면 interrupted(), isInterrupted()메소드는 true를 리턴한다. (o)
 3. 메인 스레드에서 1초후 MovieThread의 interrupt() 메소드를 호출해서 MovieThread를 안전하게 종료하고 싶다.
    빈칸에 적당한 코드를 작성해보자.
    ( ThreadExample.java , MovieThread.java / package ch12.sec02.verify.exam03; )
 4. 메인 스레드가 종료되면 MovieThread도 같이 종료되게 만들고 싶다.
    빈칸에 적당한 코드를 넣어보자.
    ( ThreadExample.java , MovieThread.java / package ch12.sec02.verify.exam04; )
 5. while문으로 반복적인 작업을 하는 스레드를 종료하는 방법에 대한 설명 중 최선의 방법이 아닌 것은?
  5-1.stop() 메소드를 호출해서 즉시 종료시킨다. (x)
  5-2.조건식에 boolean 타입의 stop 플래그를 이용해서 while문을 빠져나가게 한다. (o)
  5-3.스레드가 반복적으로 일시 정지 상태가 된다면 InterruptedException을 발생시켜 예외 처리 코드에서 break문으로 while문을 빠져나가게 한다. (o)
  5-4.스레드가 일시 정지 상태로 가지 않는다면 isInterrupted()나 interrupted() 메소드의 리턴값을 조사해서 true일 경우 break문으로 while문을 빠져나가게 한다. (o)