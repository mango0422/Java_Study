*매개 변수의 개수를 모를 경우

메소드의 매개 변수는 개수가 이미 정해져 있는 것이 일반적이지만, 어떤 상황에서는 메소드를 선언할 대 매개 변수의 개수를 알 수 없는 경우도 있습니다.
예를 들어 여러 개의 수를 모두 합산하는 메소드를 선언해야 한다면 몇 개의 매개 변수가 입력될지 알 수 없기 대문에 매개 변수의 개수를 결정할 수 없을 것이다.

해결책은 다음과 같이 매개 변수를 배열 차입으로 선언하는 것이다.

int sum(int[] values){  }

sum1() 메소드를 호출할 때 배열을 넘겨줌으로써 배열의 항목 값들을 모두 전달할 수 있다.
배열의 항목 수는 호출할 때 결정된다.

int[] values = { 1, 2, 3 };
int result = sum1(values);
int result = sum1(new int[] { 1, 2, 3, 4, 5 });

매개 변수를 배열 타입으로 선언하면 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다.
그래서 배열을 생성하지 않고 값의 목록만 넘겨주는 방법도 있다.
다음과 같이 sum2() 메소드의 매개 변수를 ...를 사용해서 선언하게 되면 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.

int sum2(int ... values){   }
...로 선언된 매개 변수의 값은 다음과 같이 메소드 호출 시 쉼표로 나열해주면 된다.

int result = sum2(1, 2, 3);
int result = sum2(1, 2, 3, 4, 5);

...로 선언된 매개 변수는 배열 타입이므로 다음과 같이 배열을 직접 매개값으로 사용해도 좋다.

int[] values = { 1, 2, 3 };
int result = sum2(values);
int result = sum2(new int[] {1, 2, 3, 4, 5});
___________________________________________________________________________________________________________________________________________________________

<리턴(Return)문>
*리턴값이 있는 메소드
메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 리턴값을 지정해야 한다.
만약 return문이 없다면 컴파일 에러가 발생하고, return문이 실행되면 메소드는 즉시 종료된다.

return문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 한다.
예를 들어 리턴타입이 int인 plus() 메소드에서는 byte, short, int의 값이 리턴되어도 상관없다.
byte, short는 int로 자동타입변환되어 리턴되기 때문이다.

return문 이후의 실행문은 결코 실행되지 않는다. 그렇기 때문에 return 이후에 실행문이 오면 "Unreachable code"라는 컴파일 에러가 발생한다.

*리턴값이 없는 메소드: void
리턴값이 없는 메소드는 리턴 타입으로 void를 사용한다.
그런데 void로 선언된 메소드에서도 return문을 사용할 수 있다.
이것은 리턴값을 지정하는 것이 아니라 메소드 실행을 강제 종료시키는 역할을 한다.

다음은 gas값이 0보다 클 경우 계속해서 while문을 실행하고, 0일 경우 return문을 실행해서 run() 메소드를 즉시 종료한다.
while문이 한번 루핑할 때마다 gas를 1씩 감소하기 때문에 언젠가는 0이 되어 run() 메소드를 종료한다.
___________________________________________________________________________________________________________________________________________________________

<메소드 호출>
메소드는 클래스 내·외부의 호출에 의해 실행된다.
클래스 내부의 다른 메소드에서 호출할 경우에는 단순한 메소드 이름으로 호출하면 되지만, 클래스 외부에서 호출할 경우에는 우선 클래스로부터 객체를 생성한 뒤 참조 변수를 이용해서 메소드를 호출해야 한다.
객체가 존재해야 메소드도 존재하기 때문이다.

*객체 내부에서 호출
클래스 내부에서 다른 메소드를 호출할 경우에는 다음과 같은 형태로 작성하면 된다.
메소드가 매개 변수를 가지고 있을 때에는 매개 변수의 타입과 수에 맞게 매개값을 제공한다.

예를 들어 method2() 메소드에서 method1() 메소드를 호출하려면, 
public class ClassName{
    void method1(String p1, int p2){
        ...
    }
    void method2(){
        method1("홍길동", 100);
    }
}
