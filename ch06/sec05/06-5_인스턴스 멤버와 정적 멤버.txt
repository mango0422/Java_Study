클래스는 객체의 설계도이다.
클래스 멤버(필드, 메소드)는 당연히 객체에도 포함되어 있어야 한다.
하지만 이것이 과연 효율적인지는 생각해볼 필요가 있다.

클래스로부터 객체(인스턴스)는 하나가 아니라 여러 개가 만들어질 수 있다.
이 경우 클래스 멤버들은 객체마다 모두 가지고 있을 필요가 있을까?

예를 들어 객체마다 필드값이 달라야 한다면 해당 필드는 객체마다 가지고 있는 것이 맞다.
하지만 객체 필드값이 모두 같아야 한다면 이 필드를 객체마다 가지고 있을 필요가 있을까?
만약 객체마다 갖고 있다면 메모리 낭비가 되며, 모든 객체의 필드값을 같게 맞추는 추가적인 작업이 필요할 수도 있다.
오히려 이런 필드는 한 곳에 위치시키고 객체들이 공유하는 것이 좋을 수 있다.

자바는 이런 경우를 위해 클래스 멤버를 인스턴스 멤버와 정적 멤버로 구분해서 선언할 수 있도록 하고 있다.
인스턴스 멤버는 객체마다 가지고 있는 멤버를 말하고, 정적 멤버는 클래스에 위치시키고 객체들이 공유하는 멤버를 말한다.

<인스턴스 멤버와 this>
인스턴스(instance) 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.
우리가 지금까지 작성한 모든 필드와 메소드는 인스턴스 멤버였다.
인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다.

*인스턴스 멤버 선언
인스턴스 필드와 메소드를 선언하는 방법은 지금까지 학습했던 내용과 다르지 않다.
다음은 Car클래스에서 인스턴스 필드 gas와 인스턴스 메소드 setSpeed()를 선언하였다.
public class Car{
    //필드
    int gas;

    //메소드
    void setSpeed(int speed){...}
}

gas 필드와 setSpeed() 메소드는 인스턴스 멤버이기 때문에 외부 클래스에서 사용하기 위해서는 우선 Car 객체(인스턴스)를 생성하고 참조 변수 myCar 또는 yourCar로 접근해야 한다.
Car myCar = new Car();
myCar.gas = 10;
myCar.setSpeed(60);

Car yourCar = new Car();
yourCar.gas = 20;
yourCar.setSpeed(80);

위 코드가 실행된 후, 인스턴스 필드 gas는 객체마다 따로 존재하고, 인스턴스 메소드 setSpeed()는 메소드 영역에 저장되고 공유된다.

인스턴스 메소드는 객체에 소속된 멤버인데, 왜 객체 내부에 존재하지 않고 메소드 영역에 저장되고 공유된다고 했을까?
메소드는 코드 블록이므로 객체마다 동일한 코드 블록을 가지고 있을 필요가 없기 때문이다.
그렇다면 인스턴스라는 용어를 붙인 이유는 메모드 블록 내부에 인스턴스 필드 등이 사용되는 경우가 있기 때문이다.
인스턴스 필드가 사용되면 메소드 역시 객체 없이는 실행할 수 없다.

*this
객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다.
우리가 자신을 '나'라고 가리키듯이 객체는 자신을 this라고 한다.
따라서 this.model은 자신이 가지고 있는 model 필드라는 뜻이다.
this는 주로 생성자와 메소드의 매개 변수 이름이 피드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.

다음은 매개 변수 model의 값을 필드 model에 저장한다.

Car(String model){
    this.model = model;
}

void setModel(String model){
    this.model = model;
}
______________________________________________________________________________________________________________________________________________________________________________________

<정적 멤버와 static>
정적(static)은 '고정된'이란 의미이다.
정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.
이들은 각각 정적 필드, 정적 메소드라고 부른다.

*정적 멤버 선언
정적 필드와 정적 메소드를 선언하려면 필드와 메소드 선언 시 static 키워드를 추가적으로 붙이면 된다.
다음은 정적 필드와 정적 메소드를 선언하는 방법을 보여준다.
public class 클래스{
    //정적 필드
    static 타입 필드 [=초기값];

    //정적 메소드
    static 리턴 타입 메소드( 매개변수선언, ... ){ ... }
}

정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다.
따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.

인스턴스 필드 선언 - 객체마다 가지고 있어야할 데이터
정적 필드 선언 - 객체마다 가지고 있을 필요가 없는 공용 데이터

예를 들어 Calculator 클래스에서 원의 넓이나 둘레를 구할 때 필요한 파이(π)는 Calculator 객체마다 가지고 있을 필요가 없는 변하지 않는 공용 데이터이므로 정적 필드로 선언하는 것이 좋다.
그러나 Calculator별로 색깔이 다르다면 color는 인스턴스 필드로 선언해야 한다.
public class Calculator {
    String color;                   //계산기별로 색깔이 다를 수 있다.
    static double pi = 3.14159;     //계산기에서 사용하는 파이(π) 값은 동일하다.
}

메소드 역시 인스턴스 메소드로 선언할 것인가, 아니면 정적 메소드로 선언할 것인가의 판단 기준이 필요하다.
인스턴스 필드를 포함하고 있다면 인스턴스 메소드로 선언하고, 인스턴스 필드를 포함하고 있지 않다면 정적 메소드로 선언한다.

예를 들어 Calculator 클래스의 덧셈, 뺄셈 기능은 인스턴스 필드를 이용하기보다는 외부에서 주어진 매개값들을 가지고 덧셈과 뺄셈을 수행하므로 정적 메소드로 선언하는 것이 좋다.
그러나 인스턴스 필드인 색깔을 변경하는 메소드는 인스턴스 메소드로 선언해야 한다.
public class Calculator {
    String color;                                       // 인스턴스 필드
    static Setcolor(String color){this.color = color;}  // 인스턴스 메소드
    static int plus(int x, int y){return x + y;}        // 정적 메소드
    static int minus(int x, int y){return x - y;}       // 정적 메소드
}

*정적 멤버 사용
클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데, 클래스 이름과 함께 도트(.) 연산자로 접근한다. (ex. 클래스.필드; 클래스.메소드( 매개값, ... );)

예를 들어 Calculator 클래스가 다음과 같이 작성되었다면
public class Calculator{
    static double pi = 3.14159;
    static int plus(int x, int y){...};
    static int minus(int x, int y){...};
}
정적 필드 pi와 정적 메소드 plus(), minus()는 다음과 같이 사용할 수 있다.