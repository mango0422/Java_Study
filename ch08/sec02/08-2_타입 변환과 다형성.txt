프로그램을 개발할 때 인터페이스를 사용해서 메소드를 호출하도록 코딩했다면, 구현 객체를 매우 손쉽고 빠르게 교체할 수 있다.
프로그램 소스 코드는 변함이 없는데, 구현 객체를 교체함으로써 프로그램의 실행결과가 다양해진다.
이것이 '인터페이스의 다형성' 이다.

다음과 같이 I 인터페이스를 이용해서 프로그램을 개발했다.
I 인터페이스를 구현한 클래스로 처음에는 A 클래스를 선택했는데, 테스트를 해보니 A 클래스에 문제가 있다는 것을 알았다.
그래서 B 클래스와 교체한 후 단 한 줄만 수정해서 프로그램을 재실행할 수 있다.

interface I{
    void method1();
    void method2();
}

[프로그램]
//I i = new A();
I i = new B();

i.method1();
i.method2();
______________________________________________________________________________________________________________________________________________________________________________________

<자동 타입 변환>
구현 객체가 인터페이스 타입으로 변환되는 것은 자동 타입 변환(promotion)에 해당한다.
자동 타입 변환은 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말한다.
인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환할 수 있다.
B b = new B();
C c = new C();
D d = new D();
E e = new E();
      ↓↓↓↓
A a1 = b;  // (가능)
A a2 = c;  // (가능)
A a3 = d;  // (가능)
A a4 = e;  // (가능)

자동 타입 변환을 이용하면 필드의 다형성과 매개 변수의 다형성을 구현할 수 있다.
필드와 매개 변수의 타입을 인터페이스로 선언하면 다양한 구현 객체를 대입해서 실행결과를 다양하게 만들 수 있다.
______________________________________________________________________________________________________________________________________________________________________________________

<필드의 다형성>
7장에서는 타이어 클래스 타입에 한국 타이어와 금호 타이어라는 자식 객체를 대입해서 교체할 수 있음을 보여주었지만, 여기서는 타이어가 클래스 타입이 아니고 인터페이스 타입이라는 점과
한국 타이어와 금호 타이어는 자식 클래스가 아니라 금호 클래스라는 차이점이 있다.
한국 타이어와 금호 타이어는 공통적으로 타이어 인터페이스를 구현했기 때문에 모두 타이어 인터페이스에 있는 메소드를 가지고 있다.
따라서 타이어 인터페이스로 동일하게 사용할 수 있는 교체 가능한 객체에 해당한다.
 자동차를 설계할 때 다음과 같이 필드 타입으로 타이어 인터페이스를 선언하면 필드값으로 한국 타이어 또는 금호 타이어 객체를 대입할 수 있다.
자동 타입 변환이 일어나기 때문에 아무런 문제가 없다.
public class Car{
    Tire frontLeftTire = new HankookTire();
    Tire frontRightTire = new HankookTire();
    Tire backLeftTire = new HankookTire();
    Tire backRightTire = new HankookTire();
}
Car 객체를 생성한 후, 초기값으로 대입한 구현 객체 대신 다른 구현 객체를 대입할 수도 있다.
이것이 타이어 교체에 해당한다.
Car myCar = new Car();
myCar.frontLeftTire = new KumhoTire();
mycar.frontRightTire = new KumhoTire();
다음은 Car 객체의 run() 메소드에서 타이어 인터페이스에 선언된 roll() 메소드를 호출한다.
void run(){
    frontLeftTire.roll();
    frontRightTire.roll();
    backLeftTire.roll();
    backRightTire.roll();
}
frontLeftTire와 frontRightTire를 교체하기 전에는 HankookTire 객체의 roll() 메소드가 호출되지만, KumhoTire로 교체된 후에는 KumhoTire 객체의 roll() 메소드가 호출된다.
Car의 run() 메소드를 수정하지 않아도 다양한 roll() 메소드의 실행결과를 얻을 수 있게 되는 것이다.
이것이 바로 '필드의 다형성'이다.
______________________________________________________________________________________________________________________________________________________________________________________

<매개 변수의 다형성>
작동 타입 변환은 필드의 값을 대입할 때에도 발생하지만, 주로 메소드를 호출할 때 많이 발생한다.
매개값을 다양화하기 위해서 상속에서는 매개 변수를 부모 타입으로 선언하고 호출할 때에는 자식 객체를 대입했다.
 이번에는 매개 변수를 인터페이스 타입으로 선언하고 호출할 때에는 구현 객체를 대입한다.
예를 들어, 다음과 같이 Driver 클래스에는 drive() 메소드가 정의되어 있는데 Vehicle 타입의 매개 변수가 선언되어 있다.
public class Driver{
    public void drive(Vehicle vehicle){
        vehicle.run();
    }
}
Vehicle을 다음과 같이 인터페이스 타입이라고 가정해보자.
public interface Vehicle{
    public void run();
}
 만약 Bus가 구현 클래스라면 Driver의 drive() 메소드를 호출할 때 Bus 객체를 생성해서 매개값으로 줄 수 있다.
drive() 메소드는 Vehicle 타입을 매개 변수로 선언했지만, Vehicle을 구현한 Bus 객체가 매개값으로 사용되면 자동 타입 변환이 발생한다.
Vehicle vehicle = bus; (bus를 vehicle로 자동 타입 변환)
 매개 변수의 타입이 인터페이스일 경우 어떠한 구현 객체도 매개값으로 사용할 수 있고, 어떤 구현 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 있다.
이것이 인터페이스 '매개변수의 다형성'이다.
void drive(Vehicle vehicle){
    vehicle.run();  // 구현 객체의 run() 메소드가 실행됨.
}

* 여기서 잠깐만!
 인터페이스는 메소드의 매개 변수로 많이 등장한다.
인터페이스 타입으로 매개 변수를 선언하면 메소드 호출 시 매개값으로 여러 가지 종류의 구현 객체를 줄 수 있기 때문에 메소드 실행결과가 다양하게 나온다.(매개 변수의 다형성)
 useRemoteControl() 메소드의 매개 변수가 RemoteControl 인터페이스 타입일 경우, 매개값으로 Television 객체 또는 Audio 객체를 선택적으로 줄 수 있다.
메소드 호출 시 어떤 구현 객체를 매개값으로 주느냐에 따라서 useRemoteControl() 메소드의 실행결과는 다르게 나온다.
______________________________________________________________________________________________________________________________________________________________________________________

<강제 타입 변환>
구현 객체가 인터페이스 타입으로 자동 타입 변환하면, 인터페이스에 선언된 메소드만 사용 가능하다는 제약 사항이 따른다.
 예를 들어 인터페이스에는 3개의 메소드가 선언되어 있고 클래스에는 5개의 메소드가 선언되어 있다면, 인터페이스로 호출 가능한 메소드는 3개뿐이다.
하지만 경우에 따라서는 구현 클래스에 선언된 필드와 메소드를 사용해야 할 경우도 발생한다.
이 때 '강제 타입 변환'(casting)을 해서 다시 구현 클래스 타입으로 변환한 다음, 구현 클래스의 필드와 메소드를 사용할 수 있다.
______________________________________________________________________________________________________________________________________________________________________________________

<객체 타입 확인>
 강제 타입 변환은 구현 객체가 인터페이스 타입으로 변환되어 있는 상태에서 가능하다.
그러나 어떤 구현 객체가 변환되어 있는지 알 수 없는 상태에서 무작정 강제 타입 변환할 경우 ClassCastException이 발생할 수도 있다.
 예를 들어 다음과 같이 Taxi 객체가 인터페이스로 변환되어 있을 경우, Bus 타입으로 강제 타입 변환하면 구현 클래스 타입이 다르므로 ClassCastException이 발생한다.
Vehicle vehicle = new Taxi();
Bus bus = (Bus) vehicle;
 메소드의 매개 변수가 인터페이스로 선언된 경우, 메소드를 호출할 때 다양한 구현 객체들을 매개값으로 지정할 수 있다.(매개 변수의 다형성).
어떤 구현 객체가 지정될지 모르는 상황에서 다음과 같이 매개값을 Bus로 강제 타입 변환하면 ClassCastException이 발생할 수 있다.
public void drive(Vehicle vehicle){
    Bus bus = (Bus) vehicle;
    bus.checkFare();
    vehicle.run();
}
 그렇다면 어떤 구현 객체가 인터페이스 타입으로 변환되었는지 확인하는 방법은 없을까?
우리는 상속에서 객체 타입을 확인하기 위해 instanceof 연산자를 사용했다.
instanceof 연산자는 인터페이스 타입에서도 사용할 수 있다.
 예를 들어 Vehicle 인터페이스 타입으로 변환된 객체가 Bus인지 확인하려면 다음과 같이 작성하면 된다
 if(vehicle instanfceof Bus){
    Bus bus = (Bus) vehicle;
 }
 인터페이스 타입으로 자동 타입 변환된 매개값을 메소드 내에서 다시 구현 클래스 타입으로 강제 타입 변환해야 한다면 반드시 매개값이 어떤 객체인지 instanceof 연산자로 확인하고 안전하게 강제 타입 변환을 해야 한다.
 다음과 같이 drive() 메소드에서 매개값이 Bus 객체인 경우, Bus의 checkFare() 메소드를 호출해야 한다면 Bus 타입으로 강제 타입 변환을 해야 한다.
Vehicle 인터페이스에는 checkFare() 메소드가 없기 때문이다.
매개값으로 어떤 구현 객체가 대입될지 모르기 때문에 instanceof 연산자로 Bus 타입인지 꼭 확인해야 한다.
______________________________________________________________________________________________________________________________________________________________________________________

* 좀 더 알아보기 : 인터페이스 상속
 인터페이스도 다른 인터페이스를 상속할 수 있다.
 인터페이스는 클래스와는 달리 다중 상속을 허용한다.
 다음과 같이 extends 키워드 뒤에 상속할 인터페이스들을 나열할 수 있다.
 public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2 {...}
 하위 인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드뿐만 아니라 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 한다.
 그렇기 때문에 구현 클래스로부터 객체를 생성한 후 다음과 같이 하위 및 상위 인터페이스 타입으로 변환이 가능하다.
 
 하위인터페이스 변수 = new 구현클래스(...);
 상위인터페이스1 변수 = new 구현클래스(...);
 상위인터페이스2 변수 = new 구현클래스(...);