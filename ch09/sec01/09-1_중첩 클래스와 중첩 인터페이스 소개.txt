'중첩 클래스'(nested class)란 클래스 내부에 선언한 클래스를 말한다.
중첩 클래스를 사용하면 두 클래스의 멤버들을 서로 쉽게 접근할 수 있고, 외부에는 불필요한 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다는 장점이 있다.
다음은 중첩 클래스의 코드 형태를 보여준다.
class ClassName{
    class NestedClassName{  // 중첩 클래스
    }
}

인터페이스도 클래스 내부에 선언할 수 있는데, 이런 인터페이스를 '중첩 인터페이스'(nested interface)라고 한다.
인터페이스를 클래스 내부에 선언하는 이유는 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해서이다.
clas ClassName{
    interface NestedInterfaceName{  // 중첩 인터페이스
    }
}
______________________________________________________________________________________________________________________________________________________________________________________

<중첩 클래스>
중첩 클래스는 클래스 내부에 선언되는 위치에 따라서 두 가지로 분류된다.
클래스의 멤버로서 선언되는 중첩 클래스를 '멤버 클래스'라고 하고, 메소드 내부에서 선언되는 중첩 클래스를 '로컬 클래스'라고 한다.
멤버 클래스는 클래스나 객체가 사용 중이라면 언제든지 재사용이 가능하지만, 로컬 클래스는 메소드를 실행할 때만 사용되고 메소드가 종료되면 없어진다.
 중첩 클래스도 하나의 클래스이기 때문에 컴파일하면 바이트 코드 파일(.class)이 별도로 생성된다.
멤버 클래스일 경우 바이트 코드 파일의 이름은 다음과 같이 결정된다.
A $ B .class // A는 바깥 클래스, B는 멤버 클래스

로컬 클래스일 경우에는 다음과 같이 $1이 포함된 바이트 코드 파일이 생성된다.

* 인스턴스 멤버 클래스
 인스턴스 멤버 클래스는 static 키워드 없이 중첩 선언된 클래스를 말한다.
인스턴스 멤버 클래스는 인스턴스 필드와 메소드만 선언이 가능하고 정적 필드와 메소드는 선언할 수 없다.
class A {
    /**인스턴스 멤버 클래스**/
    class B{
        B(){ }                      // 생성자
        int field1;                 // 인스턴스 필드
        //static int field2;        // 정적 필드 (x)
        void method1() { }          // 인스턴스 메소드
        //static void method2() { } // 정적 메소드(x)
    }
}

A 클래스 외부에서 B 객체를 생성하려면 먼저 A 객체를 생성하고 B 객체를 생성해야 한다.
A 클래스 내부의 생성자 및 인스턴스 메소드에서는 일반 클래스처럼 B 객체를 생성할 수 있다.

A 클래스 외부
A a = new A();
A.B b = a.new B();
b.field1 = 3;
b.method1();

A 클래스 내부
class A{
    class B{...}

    void methodA(){
        B b = new B();
        b.field = 3;
        b.method1();
    }
}

일반적으로 A 클래스 외부에서 B 객체를 생성하는 일은 거의 없다.
대부분 A 클래스 내부에서 B 객체를 생성해서 사용한다.

* 정적 멤버 클래스
정적 멤버 클래스는 static 키워드로 선언된 클래스를 말한다.
정적 멤버 클래스는 모든 종류의 필드와 메소드를 선언할 수 있다.
class A{
    /**정적 멤버 클래스**/
    static class C {
        C() { }                     // 생성자
        int field1;                 // 인스턴스 필드
        static int field2;          // 정적 필드
        void method2() { }          // 인스턴스 메소드
        static void method2() { }   // 정적 메소드
    }
}

A 클래스 외부에서 정적 멤버 클래스 C의 객체를 생성하기 위해서는 A 객체를 생성할 필요가 없고, 다음과 같이 C 객체를 생성하면 된다.

A.C c = new A.C();
c.field1 = 3;       // 인스턴스 필드 사용
c.method1();        // 인스턴스 메소드 호출
A.C.field2 = 3;     // 정적 필드 사용
A.C.method2();      // 정적 메소드 호출

* 로컬 클래스
 중첩 클래스는 메소드 내에서도 선언할 수 있는데, 이것을 로컬(local) 클래스라고 한다.
로컬 클래스는 접근 제한자(public, private) 및 static을 붙일 수 없다.
로컬 클래스는 메소드 내부에서만 사용되므로 접근을 제한할 필요가 없기 때문이다.
로컬 클래스 내부에는 인스턴스 필드와 메소드만 선언할 수 있고 정적 필드와 메소드는 선언할 수 없다.
void method(){
    /**로컬 클래스**/
    class D{
        D() { }                         // 생성자
        int field1;                     // 인스턴스 필드
        //static int field2;            // 정적 필드 (x)
        void method1() { }              // 인스턴스 메소드
        //static void method2() { }     // 정적 메소드 (x)
    }
}

로컬 클래스는 메소드가 실행될 때 메소드 내에서 객체를 생성하고 사용해야 한다.
주로 다음과 같이 비동기 처리를 위해 스레드 객체를 만들 때 사용한다. (스레드는 12장에서 학습..)
void method(){
    class DownloadThread extends Thred {...}
    DownloadThread thread = new DownloadThread();
    thread.start();
}
______________________________________________________________________________________________________________________________________________________________________________________

<중첩 클래스의 접근 제한>
멤버 클래스 내부에서 바깥 클래스의 필드와 메소드에 접근할 때는 제한이 따른다.
또한 메소드의 매개 변수나 로컬 변수를 로컬 클래스에서 사용할 때도 제한이 따른다.

* 바깥 필드와 메소드에서 사용 제한
바깥 클래스에서 인스턴스 멤버 클래스를 사용할 때 제한이 있다.
다음 코드를 보면서 이해해보자. ( A.java, package ch09.sec01.exam02; )
인스턴스 멤버 클래스(B)는 바깥 클래스의 인스턴스 필드(field1)의 초기값이나 인스턴스 메소드(method1())에서 객체를 생성할 수 있으나,
정적 필드(field3)의 초기값이나 정적 메소드(method2())에서는 객체를 생성할 수 없다.
반면 정적 멤버 클래스(C)는 모든 필드의 초기값이나 모든 메소드에서 객체를 생성할 수 있다.

* 멤버 클래스에서 사용 제한
멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 멤버 클래스 내부에서 바깥 클래스의 필드와 메소드에 접근할 때에도 제한이 따른다.
인스턴스 멤버 클래스(B) 안에서는 바깥 클래스의 모든 필드와 모든 메소드에 접근할 수 있지만,
정적 멤버 클래스(C) 안에서는 바깥 클래스의 정적 필드(field2)와 메소드(method2())에만 접근할 수 있고 인스턴스 필드(field1)와 메소드(method1())에는 접근할 수 없다.

* 로컬 클래스에서 사용 제한
메소드의 매개 변수나 로컬 변수를 로컬 클래스에서 사용할 때 제한이 있다.
로컬 클래스의 객체는 메소드 실행이 종료되면 없어지는 것이 일반적이지만, 메소드가 종료되어도 계속 실행 상태로 존재할 수 있다.
예를 들어 로컬 스레드 객체를 사용할 때이다.
메소드를 실행하는 스레드와 다르므로 메소드가 종료된 후에도 로컬 스레드 객체는 실행 상태로 존재할 수 있다.
 자바는 이 문제를 해결하기 위해 컴파일 시 로컬 클래스에서 사용하는 매개 변수나 로컬 변수의 값을 로컬 클래스 내부에 복사해두고 사용한다.
그리고 매개 변수나 로컬 변수가 수정되어 값이 변경되면 로컬 클래스에 복사해둔 값과 달라지므로 문제를 해결하기 위해 매개 변수나 로컬 변수를 final로 선언할 것을 요구한다.
 그래서 자바 7 이전까지는 final 키워드 없이 선언된 매개 변수나 로컬 변수를 로컬 클래스에서 사용하면 컴파일 에러가 발생했다.
그러나 자바 8부터는 final 키워드 없이 선언된 매개 변수와 로컬 변수를 사용해도 컴파일 에러가 발행하지 않는다.
그렇다고 자바 8부터는 final이 아닌 매개 변수와 로컬 변수를 허용한다는 것은 당연히 아니다.
final 선언을 하지 않아도 값이 수정될 수 없도록 final의 특성을 부여한다.
 다음 에제( Outter.java "package ch09.exam04;" )는 매개 변수와 로컬 변수를 로컬 클래스 내부에서 사용할 때 매개 변수와 로컬 변수가 final 특성을 갖고 있음을 잘 보여준다.

* 중첩 클래스에서 바깥 클래스 참조 얻기
클래스 내부에서 this는 객체 자신의 참조이다.
중첩 클래스에서 this 키워드를 사용하면 바깥 클래스의 객체 참조가 아니라, 중첩 클래스의 객체 참조가 된다.
따라서 중첩 클래스 내부에서 'this.필드, this.메소드()'로 호출하면 중첩 클래스의 필드와 메소드가 사용된다.
 중첩 클래스 내부에서 바깥 클래스의 객체 참조를 얻으려면 바깥 클래스의 이름을 this 앞에 붙여주면 된다.
다음은 중첩 클래스 내부에서 바깥 클래스의 필드와 메소드에 접근하기 위해 '바깥 클래스.this'를 사용한 예이다.
 바깥클래스.this.필드
 바깥클래스.this.메소드();
______________________________________________________________________________________________________________________________________________________________________________________

<중첩 인터페이스>
중첩 인터페이스는 클래스의 멤버로 선언된 인터페이스를 말한다.
인터페이스를 클래스 내부에 선언하는 이유는 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해서이다.
class A {
    [static] interface I {
        void method();
    }
}

중첩 인터페이스는 인스턴스 멤버 인터페이스와 정적(static) 멤버 인터페이스 모두 가능하다.
인스턴스 멤버 인터페이스는 바깥 클래스의 객체가 있어야 사용 가능하며, 정적 멤버 인터페이스는 바깥 클래스의 객체 없이 바깥 클래스만으로 바로 접근할 수 있다.
주로 정적 멤버 인터페이스를 많이 사용하는데 UI 프로그래밍에서 이벤트를 처리할 목적으로 많이 활용된다.
 예를 들어, Button을 클릭했을 때 이벤트를 처리하는 객체를 받고 싶다고 가정해보자.
그렇다고 아무 객체나 받으면 안 되고, Button 내부에 선언된 중첩 인터페이스를 구현한 객체만 받아야 한다면 다음과 같이 Button 클래스를 선언하면 된다.
______________________________________________________________________________________________________________________________________________________________________________________

1-1. 인스턴스 멤버 클래스는 바깥 클래스의 객체가 있어야 사용될 수 있다. (O)
1-2. 정적 멤버 클래스는 바깥 클래스의 객체가 없어도 사용될 수 있다. (O)
1-3. 인스턴스 멤버 클래스 내부에는 바깥 클래스의 필드와 메소드를 사용할 수 있다. (O)
1-4. 정적 멤버 클래스 내부에는 바깥 클래스의 인스턴스 필드를 사용할 수 있다. (X)

2-1. 로컬 클래스는 생성자 또는 메소드 내부에 선언된 클래스를 말한다. (O)
2-2. 로컬 클래스도 필드와 생성자를 가질 수 있다. (O)
2-3. 로컬 클래스는 static 키워드를 이용해서 정적 클래스로 만들 수 있다. (X)
2-4. final 특성을 가진 매개 변수나 로컬 변수만 로컬 클래스 내부에서 사용할 수 있다. (O)

4. 